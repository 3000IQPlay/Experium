package dev._3000IQPlay.experium.features.modules.exploit;

import java.awt.Color;
import dev._3000IQPlay.experium.Experium;
import dev._3000IQPlay.experium.event.events.BlockEvent;
import dev._3000IQPlay.experium.event.events.Render3DEvent;
import dev._3000IQPlay.experium.features.modules.Module;
import dev._3000IQPlay.experium.features.setting.Setting;
import dev._3000IQPlay.experium.util.InventoryUtil;
import dev._3000IQPlay.experium.util.MathUtil;
import dev._3000IQPlay.experium.util.RenderUtil;
import dev._3000IQPlay.experium.util.Timer;
import net.minecraft.block.Block;
import net.minecraft.block.state.IBlockState;
import net.minecraft.init.Blocks;
import net.minecraft.init.Items;
import net.minecraft.item.ItemPickaxe;
import net.minecraft.network.Packet;
import net.minecraft.network.play.client.CPacketHeldItemChange;
import net.minecraft.network.play.client.CPacketPlayerDigging;
import net.minecraft.util.EnumFacing;
import net.minecraft.util.EnumHand;
import net.minecraft.util.math.AxisAlignedBB;
import net.minecraft.util.math.BlockPos;
import net.minecraft.util.math.MathHelper;
import net.minecraft.world.World;
import net.minecraftforge.fml.common.eventhandler.SubscribeEvent;

public class PacketmineOLD
        extends Module {
    public Setting<Boolean> autoSwitch = this.register(new Setting<Boolean>("SilentSwitch", false));
    public Setting<Boolean> render = this.register(new Setting<Boolean>("Render", true));
    public Setting<Double> resetRange = this.register(new Setting<Double>("ResetRange", 10.0, 0.0, 50.0));
    public Setting<Boolean> statusColor = this.register(new Setting<Boolean>("StatusColor", false));
    public Setting<RenderModes> renderMode = this.register(new Setting<RenderModes>("RenderMode", RenderModes.STATIC));
    public Setting<StatusModes> statusModes = this.register(new Setting<StatusModes>("StatusMode", StatusModes.STATIC));
    public Setting<Integer> red = this.register(new Setting<Integer>("Red", 0, 0, 255));
    public Setting<Integer> green = this.register(new Setting<Integer>("Green", 255, 0, 255));
    public Setting<Integer> blue = this.register(new Setting<Integer>("Blue", 0, 0, 255));
    public Setting<Integer> alpha = this.register(new Setting<Integer>("Alpha", 125, 0, 255));
    public Color fagColor;
    public BlockPos renderPos = null;
    public BlockPos breakPos = null;
    public EnumFacing breakFace = null;
    public Timer timer = new Timer();
    public boolean readyToMine = false;
    public int oldSlot = -1;

    public PacketmineOLD() {
        super("PacketmineOLD", "Breaks block with packets.", Module.Category.EXPLOIT, true, false, false);
    }

    @Override
    public void onUpdate() {
        this.fagColor = new Color(this.red.getValue(), this.green.getValue(), this.blue.getValue());
        if (PacketmineOLD.mc.player != null && PacketmineOLD.mc.world != null && this.breakPos != null) {
            float breakTime;
            this.oldSlot = PacketmineOLD.mc.player.inventory.currentItem;
            if (PacketmineOLD.mc.player.getDistanceSq(this.breakPos) > MathUtil.square(this.resetRange.getValue()) || PacketmineOLD.mc.world.getBlockState(this.breakPos).getBlock() == Blocks.AIR) {
                this.breakPos = null;
                this.breakFace = null;
                this.readyToMine = false;
                return;
            }
            if (this.render.getValue().booleanValue()) {
                this.renderPos = this.breakPos;
            }
            if (this.timer.hasReached((long)(breakTime = PacketmineOLD.mc.world.getBlockState(this.breakPos).getBlockHardness((World)PacketmineOLD.mc.world, this.breakPos)))) {
                this.readyToMine = true;
            }
            if (this.autoSwitch.getValue().booleanValue()) {
                if (this.timer.hasReached((long)breakTime) && InventoryUtil.findHotbarBlock(ItemPickaxe.class) != -1) {
                    PacketmineOLD.mc.player.connection.sendPacket((Packet)new CPacketHeldItemChange(this.pickaxeInHotbar()));
                }
                mc.getConnection().sendPacket((Packet)new CPacketPlayerDigging(CPacketPlayerDigging.Action.STOP_DESTROY_BLOCK, this.breakPos, this.breakFace));
                if (this.oldSlot != -1) {
                    PacketmineOLD.mc.player.connection.sendPacket((Packet)new CPacketHeldItemChange(this.oldSlot));
                }
            }
        }
    }

    @Override
    public void onRender3D(Render3DEvent event) {
        if (PacketmineOLD.mc.player == null || PacketmineOLD.mc.world == null) {
            return;
        }
        if (this.render.getValue().booleanValue() && this.breakPos != null && PacketmineOLD.mc.world.getBlockState(this.breakPos).getBlock() != Blocks.AIR) {
            Color defColor = new Color(this.fagColor.getRed(), this.fagColor.getGreen(), this.fagColor.getBlue(), this.alpha.getValue());
            AxisAlignedBB bb = new AxisAlignedBB((double)this.breakPos.getX() - PacketmineOLD.mc.getRenderManager().viewerPosX, (double)this.breakPos.getY() - PacketmineOLD.mc.getRenderManager().viewerPosY, (double)this.breakPos.getZ() - PacketmineOLD.mc.getRenderManager().viewerPosZ, (double)(this.breakPos.getX() + 1) - PacketmineOLD.mc.getRenderManager().viewerPosX, (double)(this.breakPos.getY() + 1) - PacketmineOLD.mc.getRenderManager().viewerPosY, (double)(this.breakPos.getZ() + 1) - PacketmineOLD.mc.getRenderManager().viewerPosZ);
            float breakTime = PacketmineOLD.mc.world.getBlockState(this.breakPos).getBlockHardness((World)PacketmineOLD.mc.world, this.breakPos);
            double progression = (float)this.timer.getPassedTimeMs() / 40.0f / breakTime * Experium.serverManager.getTpsFactor();
            double oldMaxY = bb.maxY;
            double upY = progression * (bb.maxY - bb.minY);
            AxisAlignedBB riseBB = new AxisAlignedBB(bb.minX, bb.minY, bb.minZ, bb.maxX, bb.minY + upY, bb.maxZ);
            float sGreen = MathHelper.clamp((float)((float)upY), (float)0.0f, (float)1.0f);
            Color color = this.statusModes.getValue().equals((Object)StatusModes.STATIC) ? new Color(this.timer.hasReached((long)breakTime) ? 0 : 255, this.timer.hasReached((long)breakTime) ? 255 : 0, 0, this.alpha.getValue()) : new Color(255 - (int)(sGreen * 150.0f), (int)(sGreen * 255.0f), 0, this.alpha.getValue());
            float fadeA = MathHelper.clamp((float)((float)upY), (float)0.0f, (float)1.0f);
            Color alphaFade = new Color(defColor.getRed(), defColor.getGreen(), defColor.getBlue(), (int)(fadeA * 255.0f));
            if (this.renderMode.getValue().equals((Object)RenderModes.RISE)) {
                if (riseBB.maxY <= oldMaxY) {
                    RenderUtil.drawFilledBox(riseBB, this.statusColor.getValue() != false ? color.getRGB() : defColor.getRGB());
                    RenderUtil.drawBlockOutline(riseBB, this.statusColor.getValue() != false ? color : defColor, 1.0f);
                }
                if (riseBB.maxY >= oldMaxY) {
                    RenderUtil.drawFilledBox(bb, this.statusColor.getValue() != false ? color.getRGB() : defColor.getRGB());
                    RenderUtil.drawBlockOutline(bb, this.statusColor.getValue() != false ? color : defColor, 1.0f);
                }
            } else if (this.renderMode.getValue().equals((Object)RenderModes.STATIC)) {
                RenderUtil.drawFilledBox(bb, this.statusColor.getValue() != false ? color.getRGB() : defColor.getRGB());
                RenderUtil.drawBlockOutline(bb, this.statusColor.getValue() != false ? color : defColor, 1.0f);
            } else if (this.renderMode.getValue().equals((Object)RenderModes.FADE)) {
                RenderUtil.drawFilledBox(bb, this.statusColor.getValue() != false ? new Color(color.getRed(), color.getGreen(), color.getBlue(), (int)(fadeA * 255.0f)).getRGB() : alphaFade.getRGB());
                RenderUtil.drawBlockOutline(bb, this.statusColor.getValue() != false ? new Color(color.getRed(), color.getGreen(), color.getBlue(), (int)(fadeA * 255.0f)) : alphaFade, 1.0f);
            }
        }
    }

    @SubscribeEvent
    public void onBlockEvent(BlockEvent event) {
        if (PacketmineOLD.mc.player == null || PacketmineOLD.mc.world == null) {
            return;
        }
        if (PacketmineOLD.canBlockBeBroken(event.pos)) {
            if (this.breakPos == null) {
                this.breakPos = event.pos;
                this.breakFace = event.facing;
                this.readyToMine = false;
                this.timer.reset();
            }
            PacketmineOLD.mc.player.swingArm(EnumHand.MAIN_HAND);
            PacketmineOLD.mc.player.connection.sendPacket((Packet)new CPacketPlayerDigging(CPacketPlayerDigging.Action.START_DESTROY_BLOCK, this.breakPos, this.breakFace));
            PacketmineOLD.mc.player.connection.sendPacket((Packet)new CPacketPlayerDigging(CPacketPlayerDigging.Action.STOP_DESTROY_BLOCK, this.breakPos, this.breakFace));
            event.setCanceled(true);
        }
    }

    public static boolean canBlockBeBroken(BlockPos pos) {
        IBlockState blockState = PacketmineOLD.mc.world.getBlockState(pos);
        Block block = blockState.getBlock();
        return block.getBlockHardness(blockState, (World)PacketmineOLD.mc.world, pos) != -1.0f;
    }

    public int pickaxeInHotbar() {
        for (int i = 0; i < 9; ++i) {
            if (PacketmineOLD.mc.player.inventory.getStackInSlot(i).getItem() != Items.DIAMOND_PICKAXE) continue;
            return i;
        }
        return -1;
    }

    @Override
    public void onEnable() {
        this.breakPos = null;
    }

    @Override
    public void onDisable() {
        this.breakPos = null;
    }

    @Override
    public String getDisplayInfo() {
        String t = "";
        if (this.breakPos == null) {
            return null;
        }
        if (this.breakPos != null && !this.timer.passedMs((int)(2000.0f * Experium.serverManager.getTpsFactor()))) {
            t = "\u00a7cMining";
        } else if (this.breakPos != null && this.timer.passedMs((int)(2000.0f * Experium.serverManager.getTpsFactor()))) {
            t = "\u00a7aReady";
        }
        return t;
    }

    public static enum StatusModes {
        STATIC,
        SMOOTH;
    }

    public static enum RenderModes {
        RISE,
        FADE,
        STATIC;
    }
}